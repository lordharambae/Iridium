#pragma once
#ifndef MATH_HPP
#define MATH_HPP

namespace Iridium {

	namespace Utility {

		namespace Math {

			template <class T>
			auto Modulus(const T &x) {
			}

			template <class T, class U>
			auto Remainder(const T &x, const U &y) {
			}

			template <class T, class U>
			auto Max(const T &x, const U &y) {
			}

			template <class T, class U>
			auto Min(const T &x, const U &y) {
			}

			template <class T>
			auto Ceil(const T &x) {
			}

			template <class T>
			auto Floor(const T &x) {
			}

			template <class T>
			auto Truncate(const T &x) {
			}

			template <class T>
			auto Round(const T &x) {
			}

			template <class T, class U>
			auto Power(const T &x, const U &y) {
			}

			template <class T>
			auto Exponent(const T &x) {
			}

			template <class T>
			auto SquareRoot(const T &x) {
			}

			template <class T>
			auto CubeRoot(const T &x) {
			}

			template <class T>
			auto Log(const T &x) {
			}

			template <class T>
			auto Log10(const T &x) {
			}

			template <class T>
			auto Log2(const T &x) {
			}

			template <class T>
			auto Sine(const T &x) {
			}

			template <class T>
			auto Cosine(const T &x) {
			}

			template <class T>
			auto Tangent(const T &x) {
			}

			template <class T>
			auto SineInverse(const T &x) {
			}

			template <class T>
			auto CosineInverse(const T &x) {
			}

			template <class T>
			auto TangentInverse(const T &x) {
			}

			template <class T>
			auto Sin(const T &x) {
			}

			template <class T>
			auto HyperbolicSine(const T &x) {
			}

			template <class T>
			auto HyperbolicCosine(const T &x) {
			}

			template <class T>
			auto HyperbolicTangent(const T &x) {
			}

			template <class T>
			auto HyperbolicSineInverse(const T &x) {
			}

			template <class T>
			auto HyperbolicCosineInverse(const T &x) {
			}

			template <class T>
			auto HyperbolicTangentInverse(const T &x) {
			}

		} // namespace Math

	} // namespace Utility

} // namespace Iridium

#endif